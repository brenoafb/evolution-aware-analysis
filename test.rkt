(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require math/array)
(require plot)
(require plot/no-gui)
(require "tree.rkt")
(require "array-utils.rkt")
(require "meta.rkt")
(require "plotting.rkt")
(provide tree-count-even
         tree-count-even-plain
         tree-count-even-m)
(define sleep-duration 0.0000001)
(define sleep-duration
  (make-parameter 0))
(define tree-node-hit 0)
(define (tree-value-log tree)
  (set! tree-node-hit (add1 tree-node-hit))
  (tree-value tree))
(define/memoize (tree-count-even tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))
        (else
         (+ 0 (tree-count-even (tree-left tree)) (tree-count-even (tree-right tree))))))
(define (tree-count-even-plain tree)
  (sleep (sleep-duration))
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         (+ 1
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))
        (else
         (+ 0
            (tree-count-even-plain (tree-left tree))
            (tree-count-even-plain (tree-right tree))))))
(define (tree-count-even-m tree)
  (cond ((null? tree) 0)
        ((even? (tree-value-log tree))
         `(+ 1 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))
        (else
         `(+ 0 (tree-count-even ,(tree-left tree)) (tree-count-even ,(tree-right tree))))))
(define ns (make-base-namespace))
(define (callback tree)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (make-tree-of-size n [max 100000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define iterations 1000)
(define repetitions 10)
(define starting-size 1000)
(benchmark-count-free-vars iterations)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (test-baseline)
  (define new-tree (make-tree-of-size starting-size))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000))
      (set! tree-node-hit 0)
      (tree-count-even-plain new-tree)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i tree-node-hit))))
(define (test-method)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (tree-count-even new-tree)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (tree-insert-balanced! new-tree (random 100000) callback)
      (set! tree-node-hit 0)
      (let* ((ctx (unbox (tree-count-even)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (tree-count-even) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i tree-node-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-countEven.svg"
   #:title "tree-count-even - Execution time"
   #:x-label "Nodes inserted"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  (parameterize ([plot-y-transform  log-transform]
                 [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-countEven.svg"
     #:title "tree-count-even - Node accesses"
     #:x-label "Nodes inserted"
     #:y-label "Input nodes accessed"))
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define new-tree (make-tree-of-size starting-size))
  (set-box! (tree-count-even) (hasheq)) clear cache
  (let ((method-result (tree-count-even new-tree))
        (base-result (tree-count-even-plain new-tree)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (tree-insert-balanced! new-tree (random 100000) callback)
          (set! tree-node-hit 0)
          (let* ((ctx (unbox (tree-count-even)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,new-tree)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (tree-count-even-plain new-tree))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (println "ERROR")
                (begin
                  (set-box! (tree-count-even) new-ctx)
                  (vector-set! hit-method i tree-node-hit))))))))
(test-time)
(test-correctness)
(provide (struct-out tree))
(provide make-tree-leaf)
(provide tree-is-leaf?)
(provide tree-is-node?)
(provide tree-insert-balanced!)
(struct tree
  ([value #:mutable]
   [left #:mutable]
   [right #:mutable])
  #:transparent)
(define (make-tree-leaf value)
  (tree value null null))
(define (tree-is-leaf? tree)
  (and
   (null? (tree-left tree))
   (null? (tree-right tree))))
(define (tree-is-node? tree)
  (not (tree-is-leaf? tree)))
(define (nop x)
  #t)
(define (tree-insert-balanced! tree value [callback nop])
  (begin
    (callback tree)
    (cond ((<= value (tree-value tree))
           (if (null? (tree-left tree))
               (set-tree-left! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-left tree) value callback)))
          (else
           (if (null? (tree-right tree))
               (set-tree-right! tree (make-tree-leaf value))
               (tree-insert-balanced! (tree-right tree) value callback))))))
(require plot)
(require plot/no-gui)
(provide vector-zip
         vector-range
         make-points
         id)
(define (vector-zip u v)
  (define L (min (vector-length u)
                 (vector-length v)))
  (define zipped (make-vector L))
  (for ((i L))
    (let ((x (vector-ref u i))
          (y (vector-ref v i)))
      (vector-set! zipped i (list x y))))
  zipped)
(define (vector-range lo hi)
  (define L (- hi lo))
  (define v (make-vector L))
  (for ((i L))
    (vector-set! v i (+ lo i)))
  v)
(define (make-points vec)
  (define x (vector-range 1 (add1 (vector-length vec))))
  (vector-zip x vec))
(define points-baseline
  (make-points hit-baseline))
;
(define points-method
  (make-points hit-method))
(define (id x)
  x)
;
(parameterize ([plot-y-transform  log-transform]
               [plot-y-ticks      (log-ticks)])
  (let ((y-max (* 3
                  (max
                   (vector-argmax id hit-baseline)
                   (vector-argmax id hit-method)))))
    (plot-file
     (list
      (lines points-baseline #:label "baseline" #:color 1)
      (lines points-method #:label "method" #:color 3))
     "plots/countEven-1.svg"
     #:title "countEven"
     #:x-label "Nodes inserted"
     #:y-label "Nodes accessed"
     #:y-max y-max)))
(require memo)
(require racket/hash)
(require racket/pretty)
(provide reduce!
         unfold!
         eval-lift
         update-ctx)
(define (reduce! ctx bctx f meta-f expr)
  (cons
   (car expr)
   (map (lambda (x) (unfold! ctx bctx f meta-f x)) (cdr expr))))
(define ns (make-base-namespace))
(define (unfold! ctx bctx f meta-f expr)
  (if (func-app? expr)
      (cond ((null? expr) expr)
            ((eq? (car expr) f)
             (let ((arg (cadr expr)))
               (if (in-ctx? ctx arg)
                   (ctx-get ctx arg)
                   (let ((result
                          (unfold! ctx bctx f meta-f (apply meta-f (list arg)))))
                     (begin
                       (hash-set! bctx result arg)
                       result)))))
            (else (reduce! ctx bctx f meta-f expr)))
      expr))
(define (eval-lift bctx fctx expr)
  (if (not (hash-has-key? bctx expr))
      (eval expr ns)
      (let ((src (hash-ref bctx expr)))
        (cond ((hash-has-key? fctx src)
               ; we already computed this expr
               (begin
                 (hash-ref fctx src)))
              ; haven't computed expr yet
              ((list? expr)
               (let
                   ((new-expr (map (lambda (x) (eval-lift bctx fctx x)) expr))
                    (result (eval expr ns)))
                   (begin
                     (hash-set! fctx src result)
                     result)))
              (else
               (let ((result (eval expr ns)))
                 (begin
                   (hash-set! fctx src result)
                   result)))))))
(define (update-ctx ctx fctx)
  (hash-union ctx fctx #:combine (lambda (x y) y)))
(define (eval-key-value-pair x y)
  (cons x (eval y ns)))
(define (func-app? expr)
  (if (null? expr)
      #f
      (list? expr)))
(define (in-ctx? ctx x)
  (hash-has-key? ctx x))
(define (ctx-get ctx x)
  (hash-ref ctx x))
(define (my-function)
  (for ((i 100000000))
    (add1 1))
  #t)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(provide read-from-file
         list-to-mlist
         nop
         insert-expr!
         wrap-expr
         random-atom
         mutate-expr-rand!)
; (define (max a b)
;   (if (> a b)
;       a
;       b))
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (nop x)
  #t)
(define (insert-expr! e1 e2 [callback nop])
  (callback e1)
  (cond ((null? e1) e2)
        ((null? (mcdr e1))
         (set-mcdr! e1 e2))
        (else (insert-expr! (mcdr e1) e2))))
(define (wrap-expr e)
  (list-to-mlist `(,(random-atom) ,(random-expr) ,e)))
(define (random-atom)
  'mutation)
(define maximum-mutation-depth 10)
(define (random-expr)
  (define (loop n)
    (if (= n 0)
        (random-atom)
        (let ((r (random 100)))
          (cond
            ((< r 33) (random-atom))
            ((< r 66) `(,(random-atom) ,(random-atom)))
            (else `(,(loop (- n 1)) ,(loop (- n 1))))))))
  (list-to-mlist
   (loop (random maximum-mutation-depth))))
(define (mutate-expr-rand! e [callback nop])
  (callback e)
  (cond ((null? e) e)
        ((and (mpair? e) (null? (mcdr e)))
         (set-mcdr! e (random-expr)))
        ((not (mpair? e)) (wrap-expr e))
        (else
         (let ((r (random 100)))
           (cond ((< r 96) (mutate-expr-rand! (mcdr e) callback)) ; traverse remainder of expression
                 ((< r 98)
                  (let* ((xs (mcdr e))                            ; wrap current node in some operation
                         (new-node (wrap-expr xs)))
                    (set-mcdr! e new-node)))
                 (else                                            ; insert new node here
                  (let* ((xs (mcdr e))
                         (new-node (mcons (random-expr) xs)))
                    (set-mcdr! e new-node))))))))
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  ; (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
; (plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
(define (test-method)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (expr-depth program)
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (let* ((ctx (unbox (expr-depth)))
             (bctx (make-hasheq))
             (fctx (make-hasheq))
             (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
             (result (eval-lift bctx fctx expr))
             (new-ctx (update-ctx ctx fctx)))
        (begin
          (define end-time (current-inexact-monotonic-milliseconds))
          ; (println (format "expr: ~a" expr))
          (if (= r (- repetitions 1))
              (set-box! (expr-depth) new-ctx)
              '())
          (array-set-index! time-method i r (- end-time start-time))
          (vector-set! hit-method i expr-hit))))))
(define (test-time)
  (println "Running baseline")
  (test-baseline)
  (println "Running method")
  (test-method)
  (define avg-time-baseline
    (make-avgs time-baseline iterations repetitions))
  (define avg-time-method
    (make-avgs time-method iterations repetitions))
  (define time-points-baseline (make-points avg-time-baseline))
  (define time-points-method (make-points avg-time-method))
  (plot-file
   (list
    (lines time-points-baseline #:label "baseline" #:color 1)
    (lines time-points-method #:label "method" #:color 3))
   "plots/time-expr-depth.svg"
   #:title "expr-depth - Execution time"
   #:x-label "Iterations"
   #:y-label "Analysis time (ms)")
  (define hit-points-baseline (make-points hit-baseline))
  (define hit-points-method (make-points hit-method))
  ; (parameterize ([plot-y-transform  log-transform]
  ;                [plot-y-ticks      (log-ticks)])
    (plot-file
     (list
      (lines hit-points-baseline #:label "baseline" #:color 1)
      (lines hit-points-method #:label "method" #:color 3))
     "plots/hit-expr-depth.svg"
     #:title "expr-depth - Expression accesses"
     #:x-label "Iterations"
     #:y-label "Expresion node accesses"); )
  (for ((item (list (list time-baseline "time-baseline")
                    (list time-method   "time-method")
                    (list hit-baseline  "hit-baseline")
                    (list hit-method    "hit-method"))))
    (define out
      (open-output-file
       (format "experimental-data/expr-depth-~a.txt" (cadr item))
       #:exists 'replace))
    (display (cadr item) out)
    (close-output-port out)))
(define (test-correctness)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (expr-depth) (hasheq)) ; clear cache
  (let ((method-result (expr-depth program))
        (base-result (expr-depth-plain program)))
    (if (not (eq? method-result base-result))
        'FAIL
        (for ((i iterations))
          (mutate-expr-rand! program callback)
          (set! expr-hit 0)
          (let* ((ctx (unbox (expr-depth)))
                 (bctx (make-hasheq))
                 (fctx (make-hasheq))
                 (expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
                 (result (eval-lift bctx fctx expr))
                 (base-result (expr-depth-plain program))
                 (new-ctx (update-ctx ctx fctx)))
            (if (not (eq? result base-result))
                (begin
                  (println "ERROR")
                  (println (format "result: ~a" result))
                  (println (format "base result: ~a" base-result)))
                (begin
                  (set-box! (expr-depth) new-ctx)
                  (vector-set! hit-method i expr-hit))))))))
(test-time)
(test-correctness)
(define program
  (list-to-mlist '(+ 1 (+ 2 (+ 3 (+ 4 5))))))
(set-box! (expr-depth) (hasheq)) ; clear cache
(define method-result (expr-depth program))
(define base-result (expr-depth-plain program))
(mutate-expr-rand! program callback)
(define ctx (unbox (expr-depth)))
(define bctx (make-hasheq))
(define fctx (make-hasheq))
(define expr (unfold! ctx bctx 'expr-depth expr-depth-m `(expr-depth ,program)))
(define result (eval-lift bctx fctx expr))
(define base-result (expr-depth-plain program))
(define new-ctx (update-ctx ctx fctx))
(require memo)
(require racket/hash)
(require racket/pretty)
(require profile)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (and (equal? (mcar expr) 'define)
              (mpair? (mcar (mcdr expr)))))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (func-params expr)
  (mcdr (mcar (mcdr expr))))
(define (mmember x xs)
  (cond ((null? xs) false)
        ((eq? x (mcar xs)) #t)
        (else (mmember x (mcdr xs)))))
(func-params
 (list-to-mlist
  '(define (func-params x y z)
     (mcdr (mcar (mcdr expr))))))
(define (count-free-vars-plain p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars-plain (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars p)
  (cond ((null? p) 0)
        ((mpair? p)
         (+ (count-free-vars-function (mcar p))
            (count-free-vars (mcdr p))))
        (else 0)))
(define/memoize (count-free-vars-meta p)
  (cond ((null? p) 0)
        ((mpair? p)
         `(+ ,(count-free-vars-function (mcar p))
              (count-free-vars ,(mcdr p))))
        (else 0)))
(define (count-free-vars-function f)
  (define (loop vars expr)
    (cond ((null? expr) 0)
          ((mpair? expr)
           (+
            (loop vars (mcar expr))
            (loop vars (mcdr expr))))
          ((mmember expr vars) 0)
          (else
            (begin
              ; (println expr)
              1))))
  ; (println (func-params f))
  ; (println (func-body f))
  (if (func-def? f)
      (loop (func-params f) (func-body f))
      0))
(count-free-vars
 (list-to-mlist
  '((define (f x y)
      (* (+ x y))))))
(define ns (make-base-namespace))
(define (callback expr)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (count-free-vars)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (count-free-vars) new-ctx))
(define (benchmark-count-free-vars iterations)
  (define new-program (list-to-mlist (read-from-file "test.rkt")))
  (println "method")
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (time
   (begin
     (count-free-vars new-program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! new-program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,new-program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
  (println "base")
  (define new-program-1 (list-to-mlist (read-from-file "test.rkt")))
  (time
   (for ((i iterations))
     (begin
        (mutate-expr-rand! new-program-1)
        (count-free-vars-plain new-program-1)))))
(define iterations 1000)
; (benchmark-count-free-vars iterations)
(define (test-baseline iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (begin
      (mutate-expr-rand! program)
      (count-free-vars-plain program))))
(define (test-method iterations)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (set-box! (count-free-vars) (hasheq)) ; clear cache
  (begin
     (count-free-vars program)
     (for ((i iterations))
       (begin
         (mutate-expr-rand! program callback)
         (let* ((ctx (unbox (count-free-vars)))
                (bctx (make-hasheq))
                (expr (unfold! ctx bctx 'count-free-vars count-free-vars-meta `(count-free-vars ,program)))
                (result (eval expr ns))
                (new-ctx (enrich-ctx ctx bctx)))
           (set-box! (count-free-vars) new-ctx))))))
(display "\n----------------------- baseline ------------------------\n\n")
(profile-thunk (thunk (test-baseline iterations)))
(display "\n------------------------ method ------------------------\n\n")
(profile-thunk (thunk (test-method iterations)))
(require racket/hash)
(require racket/pretty)
(require "tree.rkt")
(require "tree-analysis.rkt")
(require "meta.rkt")
(define ns (make-base-namespace))
(define (callback tree)
  ; (println (format "tree: ~a" tree))
  (define ctx (unbox (tree-count-even)))
  (define new-ctx (hash-remove ctx tree))
  (set-box! (tree-count-even) new-ctx))
(define (loop-tree tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k callback)
            (let* ((ctx (unbox (tree-count-even)))
                  (bctx (make-hasheq))
                  (expr (unfold! ctx bctx 'tree-count-even tree-count-even-m `(tree-count-even ,tree)))
                  (result (eval expr ns))
                  (new-ctx (enrich-ctx ctx bctx)))
              (begin
                ; (println (format "partial expr: ~a" expr))
                (set-box! (tree-count-even) new-ctx)
                (loop-tree tree (- n 1)))))))))
(define (loop-tree-plain tree n)
  (if (= n 0)
      #t
      (begin
        (let ((k (random 1000)))
          (begin
            (tree-insert-balanced! tree k)
            (tree-count-even-plain tree)
            (loop-tree tree (- n 1)))))))
(define (make-tree-of-size n [max 1000])
  (let ((new-tree (make-tree-leaf (random max))))
    (for/list ([i n])
      (tree-insert-balanced! new-tree (random max)))
    new-tree))
(define starting-size 5000)
(define iterations 100)
(define (benchmark-tree)
  (define new-tree (make-tree-of-size starting-size))
  (println "method")
  (set-box! (tree-count-even) (hasheq))
  (time
   (begin
     (tree-count-even new-tree)
     (loop-tree new-tree iterations)))
  (define new-tree-1 (make-tree-of-size starting-size))
  (println "base")
  (time (loop-tree-plain new-tree-1 iterations)))
(benchmark-tree)
(require "lisp-analysis.rkt")
(define (read-from-file f)
  (let ((input (open-input-file f)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))
(define (list-to-mlist l)
  (cond ((null? l) '())
        ((pair? l)
         (mcons
          (list-to-mlist (car l))
          (list-to-mlist (cdr l))))
        (else l)))
(define (mlist-to-list l)
  (cond ((null? l) '())
        ((pair? l)
         (cons
          (mlist-to-list (mcar l))
          (mlist-to-list (mcdr l))))
        (else l)))
(define (func-def? expr)
  (cond ((null? expr) false)
        ((mpair? expr)
         (equal? (mcar expr) 'define))
        (else false)))
(define (func-body expr)
  (mcar (mcdr (mcdr expr))))
(define (mfoldr f z xs)
  (if (null? xs)
      z
      (mfoldr f (f (mcar xs) z) (mcdr xs))))
(define (mmap f xs)
  (if (null? xs)
      xs
      (mcons (f (mcar xs)) (mmap f (mcdr xs)))))
(define (sum xs)
  (mfoldr + 0 xs))
(define (sum-depths program)
  (if (null? program)
      0
      (+
       (expr-depth-plain (mcar program))
       (sum-depths (mcdr program)))))
(define (avg-function-depth program)
  (define n-funcs
    (mfoldr (lambda (e acc)
              (if (func-def? e)
                  (add1 acc)
                  acc))
           0
           program))
  (exact->inexact
   (/ (sum-depths program) n-funcs)))
(define program (list-to-mlist (read-from-file "test.rkt")))
(avg-function-depth program)
(require math/array)
(provide array-set-index!
         array-ref-index
         make-array-1
         make-avgs)
(define (array-set-index! arr i j x)
  (let ((idx (list->vector (list i j))))
    (array-set! arr idx x)))
(define (array-ref-index arr i j)
  (let ((idx (list->vector (list i j))))
    (array-ref arr idx)))
(define (make-array-1 m n)
  (array->mutable-array
   (make-array (list->vector (list m n)) 0)))
(define (make-avgs arr m n)
  (define avg (make-vector m))
  (for ((i m))
    (define sum 0)
    (for ((j n))
      (set! sum (+ sum (array-ref-index arr i j))))
    (vector-set! avg i (exact->inexact (/ sum n))))
  avg)
(require memo)
(require racket/hash)
(require racket/pretty)
(require "meta.rkt")
(require "lisp-analysis.rkt")
(require "array-utils.rkt")
(require "plotting.rkt")
(require profile)
(provide expr-depth
         expr-depth-m
         expr-depth-plain)
(define iterations 1000)
(define repetitions 10)
(define sleep-duration 0)
(define expr-hit 0)
(define hit-baseline
  (make-vector iterations))
(define hit-method
  (make-vector iterations))
(define time-baseline
  (make-array-1 iterations repetitions))
(define time-method
  (make-array-1 iterations repetitions))
(define (expr-car-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcar expr))
(define (expr-cdr-log expr)
  (set! expr-hit (add1 expr-hit))
  (mcdr expr))
(define (callback expr)
  (println (format "tree: ~a" tree))
  (define ctx (unbox (expr-depth)))
  (define new-ctx (hash-remove ctx expr))
  (set-box! (expr-depth) new-ctx))
(define (expr-depth-plain expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth-plain (expr-car-log expr)))
              (expr-depth-plain (expr-cdr-log expr))))
        (else 0)))
(define/memoize (expr-depth expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         (max (+ 1 (expr-depth (expr-car-log expr))) (expr-depth (expr-cdr-log expr))))
        (else 0)))
(define (expr-depth-m expr)
  (cond ((null? expr) 0)
        ((mpair? expr)
         `(max (+ 1 (expr-depth ,(expr-car-log expr))) (expr-depth ,(expr-cdr-log expr))))
        (else 0)))
(define ns (make-base-namespace))
(require plot)
(require plot/no-gui)
(define points-baseline
  (make-points hit-baseline))
(define points-method
  (make-points hit-method))
(plot-new-window? #t)
(define (id x)
  x)
(define (test-baseline)
  (define program (list-to-mlist (read-from-file "test.rkt")))
  (for ((i iterations))
    (for ((r repetitions))
      (define start-time (current-inexact-monotonic-milliseconds))
      (mutate-expr-rand! program callback)
      (set! expr-hit 0)
      (expr-depth-plain program)
      (define end-time (current-inexact-monotonic-milliseconds))
      (array-set-index! time-baseline i r (- end-time start-time))
      (vector-set! hit-baseline i expr-hit))))
